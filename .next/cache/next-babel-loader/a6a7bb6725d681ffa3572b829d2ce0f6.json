{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\n\nvar CV = /*#__PURE__*/function () {\n  function CV() {\n    _classCallCheck(this, CV);\n  }\n\n  _createClass(CV, [{\n    key: \"load\",\n\n    /**\n     * We will use this method privately to communicate with the worker and\n     * return a promise with the result of the event. This way we can call\n     * the worker asynchronously.\n     */\n    // _dispatch(event) {\n    //   const { msg } = event;\n    //   this._status[msg] = ['loading'];\n    //   this.worker.postMessage(event);\n    //   return new Promise((res, rej) => {\n    //     let interval = setInterval(() => {\n    //       const status = this._status[msg];\n    //       // if (!status || status == undefined) res(true);\n    //       if (status[0] === 'done') {\n    //         res(status[1]);\n    //       } else if (status[0] === 'error') rej(status[1]);\n    //       else if (status[0] !== 'loading') {\n    //         delete this._status[msg];\n    //         clearInterval(interval);\n    //       }\n    //     }, 0);\n    //   });\n    // }\n\n    /**\n     * First, we will load the worker and we will capture the onmessage\n     * and onerror events to know at all times the status of the event\n     * we have triggered.\n     *\n     * Then, we are going to call the 'load' event, as we've just\n     * implemented it so that the worker can capture it.\n     */\n    value: function load() {\n      var _this = this;\n\n      this._status = {};\n      this.worker = new Worker('/js/worker.js'); // load worker\n      // Capture events and save [status, event] inside the _status object\n\n      this.worker.onmessage = function (e) {\n        return _this._status[e.data.msg] = ['done', e];\n      };\n\n      this.worker.onerror = function (e) {\n        return _this._status[e.data.msg] = ['error', e];\n      }; // return this._dispatch({ msg: 'load' });\n\n    }\n    /**\n     * We are going to use the _dispatch event that we created before to\n     * call the postMessage with the msg and the image as payload.\n     *\n     * Thanks to what we have implemented in the _dispatch, this will\n     * return a promise with the processed image.\n     */\n\n  }, {\n    key: \"imageProcessing\",\n    value: function imageProcessing(payload) {// return this._dispatch({ msg: 'imageProcessing', payload });\n    }\n  }, {\n    key: \"predict\",\n    value: function predict(payload) {// return this._dispatch({ msg: 'predict', payload });\n    }\n  }]);\n\n  return CV;\n}(); // Export the same instant everywhere\n\n\nexport default new CV();","map":{"version":3,"sources":["/Users/jervinmacalawa/Signify/services/service.js"],"names":["CV","_status","worker","Worker","onmessage","e","data","msg","onerror","payload"],"mappings":";;;IAAMA,E;;;;;;;;AACJ;AACF;AACA;AACA;AACA;AACE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;2BACS;AAAA;;AACL,WAAKC,OAAL,GAAe,EAAf;AACA,WAAKC,MAAL,GAAc,IAAIC,MAAJ,CAAW,eAAX,CAAd,CAFK,CAEsC;AAE3C;;AACA,WAAKD,MAAL,CAAYE,SAAZ,GAAwB,UAACC,CAAD;AAAA,eAAQ,KAAI,CAACJ,OAAL,CAAaI,CAAC,CAACC,IAAF,CAAOC,GAApB,IAA2B,CAAC,MAAD,EAASF,CAAT,CAAnC;AAAA,OAAxB;;AACA,WAAKH,MAAL,CAAYM,OAAZ,GAAsB,UAACH,CAAD;AAAA,eAAQ,KAAI,CAACJ,OAAL,CAAaI,CAAC,CAACC,IAAF,CAAOC,GAApB,IAA2B,CAAC,OAAD,EAAUF,CAAV,CAAnC;AAAA,OAAtB,CANK,CAOL;;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;oCACkBI,O,EAAS,CACvB;AACD;;;4BAEOA,O,EAAS,CACf;AACD;;;;KAGH;;;AACA,eAAe,IAAIT,EAAJ,EAAf","sourcesContent":["class CV {\n  /**\n   * We will use this method privately to communicate with the worker and\n   * return a promise with the result of the event. This way we can call\n   * the worker asynchronously.\n   */\n  // _dispatch(event) {\n  //   const { msg } = event;\n  //   this._status[msg] = ['loading'];\n  //   this.worker.postMessage(event);\n  //   return new Promise((res, rej) => {\n  //     let interval = setInterval(() => {\n  //       const status = this._status[msg];\n  //       // if (!status || status == undefined) res(true);\n  //       if (status[0] === 'done') {\n  //         res(status[1]);\n  //       } else if (status[0] === 'error') rej(status[1]);\n  //       else if (status[0] !== 'loading') {\n  //         delete this._status[msg];\n  //         clearInterval(interval);\n  //       }\n  //     }, 0);\n  //   });\n  // }\n\n  /**\n   * First, we will load the worker and we will capture the onmessage\n   * and onerror events to know at all times the status of the event\n   * we have triggered.\n   *\n   * Then, we are going to call the 'load' event, as we've just\n   * implemented it so that the worker can capture it.\n   */\n  load() {\n    this._status = {};\n    this.worker = new Worker('/js/worker.js'); // load worker\n\n    // Capture events and save [status, event] inside the _status object\n    this.worker.onmessage = (e) => (this._status[e.data.msg] = ['done', e]);\n    this.worker.onerror = (e) => (this._status[e.data.msg] = ['error', e]);\n    // return this._dispatch({ msg: 'load' });\n  }\n\n  /**\n   * We are going to use the _dispatch event that we created before to\n   * call the postMessage with the msg and the image as payload.\n   *\n   * Thanks to what we have implemented in the _dispatch, this will\n   * return a promise with the processed image.\n   */\n  imageProcessing(payload) {\n    // return this._dispatch({ msg: 'imageProcessing', payload });\n  }\n\n  predict(payload) {\n    // return this._dispatch({ msg: 'predict', payload });\n  }\n}\n\n// Export the same instant everywhere\nexport default new CV();\n"]},"metadata":{},"sourceType":"module"}