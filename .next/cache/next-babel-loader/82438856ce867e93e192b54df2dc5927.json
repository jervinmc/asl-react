{"ast":null,"code":"class CV {\n  /**\n   * We will use this method privately to communicate with the worker and\n   * return a promise with the result of the event. This way we can call\n   * the worker asynchronously.\n   */\n  _dispatch(event) {\n    const {\n      msg\n    } = event;\n    this._status[msg] = ['loading'];\n    this.worker.postMessage(event);\n    return new Promise((res, rej) => {\n      let interval = setInterval(() => {\n        const status = this._status[msg]; // if (!status || status == undefined) res(true);\n\n        if (status[0] === 'done') {\n          res(status[1]);\n        } else if (status[0] === 'error') rej(status[1]);else if (status[0] !== 'loading') {\n          delete this._status[msg];\n          clearInterval(interval);\n        }\n      }, 0);\n    });\n  }\n  /**\n   * First, we will load the worker and we will capture the onmessage\n   * and onerror events to know at all times the status of the event\n   * we have triggered.\n   *\n   * Then, we are going to call the 'load' event, as we've just\n   * implemented it so that the worker can capture it.\n   */\n\n\n  load() {\n    this._status = {};\n    this.worker = new Worker('/js/worker.js'); // load worker\n    // Capture events and save [status, event] inside the _status object\n\n    this.worker.onmessage = e => this._status[e.data.msg] = ['done', e];\n\n    this.worker.onerror = e => this._status[e.data.msg] = ['error', e];\n\n    return this._dispatch({\n      msg: 'load'\n    });\n  }\n  /**\n   * We are going to use the _dispatch event that we created before to\n   * call the postMessage with the msg and the image as payload.\n   *\n   * Thanks to what we have implemented in the _dispatch, this will\n   * return a promise with the processed image.\n   */\n\n\n  imageProcessing(payload) {\n    return this._dispatch({\n      msg: 'imageProcessing',\n      payload\n    });\n  }\n\n  predict(payload) {\n    return this._dispatch({\n      msg: 'predict',\n      payload\n    });\n  }\n\n} // Export the same instant everywhere\n\n\nexport default new CV();","map":{"version":3,"sources":["/Users/jervinmacalawa/Signify/services/service.js"],"names":["CV","_dispatch","event","msg","_status","worker","postMessage","Promise","res","rej","interval","setInterval","status","clearInterval","load","Worker","onmessage","e","data","onerror","imageProcessing","payload","predict"],"mappings":"AAAA,MAAMA,EAAN,CAAS;AACP;AACF;AACA;AACA;AACA;AACEC,EAAAA,SAAS,CAACC,KAAD,EAAQ;AACf,UAAM;AAAEC,MAAAA;AAAF,QAAUD,KAAhB;AACA,SAAKE,OAAL,CAAaD,GAAb,IAAoB,CAAC,SAAD,CAApB;AACA,SAAKE,MAAL,CAAYC,WAAZ,CAAwBJ,KAAxB;AACA,WAAO,IAAIK,OAAJ,CAAY,CAACC,GAAD,EAAMC,GAAN,KAAc;AAC/B,UAAIC,QAAQ,GAAGC,WAAW,CAAC,MAAM;AAC/B,cAAMC,MAAM,GAAG,KAAKR,OAAL,CAAaD,GAAb,CAAf,CAD+B,CAE/B;;AACA,YAAIS,MAAM,CAAC,CAAD,CAAN,KAAc,MAAlB,EAA0B;AACxBJ,UAAAA,GAAG,CAACI,MAAM,CAAC,CAAD,CAAP,CAAH;AACD,SAFD,MAEO,IAAIA,MAAM,CAAC,CAAD,CAAN,KAAc,OAAlB,EAA2BH,GAAG,CAACG,MAAM,CAAC,CAAD,CAAP,CAAH,CAA3B,KACF,IAAIA,MAAM,CAAC,CAAD,CAAN,KAAc,SAAlB,EAA6B;AAChC,iBAAO,KAAKR,OAAL,CAAaD,GAAb,CAAP;AACAU,UAAAA,aAAa,CAACH,QAAD,CAAb;AACD;AACF,OAVyB,EAUvB,CAVuB,CAA1B;AAWD,KAZM,CAAP;AAaD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEI,EAAAA,IAAI,GAAG;AACL,SAAKV,OAAL,GAAe,EAAf;AACA,SAAKC,MAAL,GAAc,IAAIU,MAAJ,CAAW,eAAX,CAAd,CAFK,CAEsC;AAE3C;;AACA,SAAKV,MAAL,CAAYW,SAAZ,GAAyBC,CAAD,IAAQ,KAAKb,OAAL,CAAaa,CAAC,CAACC,IAAF,CAAOf,GAApB,IAA2B,CAAC,MAAD,EAASc,CAAT,CAA3D;;AACA,SAAKZ,MAAL,CAAYc,OAAZ,GAAuBF,CAAD,IAAQ,KAAKb,OAAL,CAAaa,CAAC,CAACC,IAAF,CAAOf,GAApB,IAA2B,CAAC,OAAD,EAAUc,CAAV,CAAzD;;AACA,WAAO,KAAKhB,SAAL,CAAe;AAAEE,MAAAA,GAAG,EAAE;AAAP,KAAf,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;AACEiB,EAAAA,eAAe,CAACC,OAAD,EAAU;AACvB,WAAO,KAAKpB,SAAL,CAAe;AAAEE,MAAAA,GAAG,EAAE,iBAAP;AAA0BkB,MAAAA;AAA1B,KAAf,CAAP;AACD;;AAEDC,EAAAA,OAAO,CAACD,OAAD,EAAU;AACf,WAAO,KAAKpB,SAAL,CAAe;AAAEE,MAAAA,GAAG,EAAE,SAAP;AAAkBkB,MAAAA;AAAlB,KAAf,CAAP;AACD;;AAxDM,C,CA2DT;;;AACA,eAAe,IAAIrB,EAAJ,EAAf","sourcesContent":["class CV {\n  /**\n   * We will use this method privately to communicate with the worker and\n   * return a promise with the result of the event. This way we can call\n   * the worker asynchronously.\n   */\n  _dispatch(event) {\n    const { msg } = event;\n    this._status[msg] = ['loading'];\n    this.worker.postMessage(event);\n    return new Promise((res, rej) => {\n      let interval = setInterval(() => {\n        const status = this._status[msg];\n        // if (!status || status == undefined) res(true);\n        if (status[0] === 'done') {\n          res(status[1]);\n        } else if (status[0] === 'error') rej(status[1]);\n        else if (status[0] !== 'loading') {\n          delete this._status[msg];\n          clearInterval(interval);\n        }\n      }, 0);\n    });\n  }\n\n  /**\n   * First, we will load the worker and we will capture the onmessage\n   * and onerror events to know at all times the status of the event\n   * we have triggered.\n   *\n   * Then, we are going to call the 'load' event, as we've just\n   * implemented it so that the worker can capture it.\n   */\n  load() {\n    this._status = {};\n    this.worker = new Worker('/js/worker.js'); // load worker\n\n    // Capture events and save [status, event] inside the _status object\n    this.worker.onmessage = (e) => (this._status[e.data.msg] = ['done', e]);\n    this.worker.onerror = (e) => (this._status[e.data.msg] = ['error', e]);\n    return this._dispatch({ msg: 'load' });\n  }\n\n  /**\n   * We are going to use the _dispatch event that we created before to\n   * call the postMessage with the msg and the image as payload.\n   *\n   * Thanks to what we have implemented in the _dispatch, this will\n   * return a promise with the processed image.\n   */\n  imageProcessing(payload) {\n    return this._dispatch({ msg: 'imageProcessing', payload });\n  }\n\n  predict(payload) {\n    return this._dispatch({ msg: 'predict', payload });\n  }\n}\n\n// Export the same instant everywhere\nexport default new CV();\n"]},"metadata":{},"sourceType":"module"}