{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\n\nvar CV = /*#__PURE__*/function () {\n  function CV() {\n    _classCallCheck(this, CV);\n  }\n\n  _createClass(CV, [{\n    key: \"_dispatch\",\n\n    /**\n     * We will use this method privately to communicate with the worker and\n     * return a promise with the result of the event. This way we can call\n     * the worker asynchronously.\n     */\n    value: function _dispatch(event) {\n      var _this = this;\n\n      var msg = event.msg;\n      this._status[msg] = ['loading'];\n      this.worker.postMessage(event);\n      return new Promise(function (res, rej) {\n        var interval = setInterval(function () {\n          var status = _this._status[msg]; // if (!status || status == undefined) res(true);\n\n          if (status[0] === 'done') {\n            res(status[1]);\n          } else if (status[0] === 'error') rej(status[1]);else if (status[0] !== 'loading') {\n            delete _this._status[msg];\n            clearInterval(interval);\n          }\n        }, 0);\n      });\n    }\n    /**\n     * First, we will load the worker and we will capture the onmessage\n     * and onerror events to know at all times the status of the event\n     * we have triggered.\n     *\n     * Then, we are going to call the 'load' event, as we've just\n     * implemented it so that the worker can capture it.\n     */\n\n  }, {\n    key: \"load\",\n    value: function load() {\n      var _this2 = this;\n\n      this._status = {};\n      this.worker = new Worker('/js/worker.js'); // load worker\n      // Capture events and save [status, event] inside the _status object\n\n      this.worker.onmessage = function (e) {\n        return _this2._status[e.data.msg] = ['done', e];\n      };\n\n      this.worker.onerror = function (e) {\n        return _this2._status[e.data.msg] = ['error', e];\n      };\n\n      return this._dispatch({\n        msg: 'load'\n      });\n    }\n    /**\n     * We are going to use the _dispatch event that we created before to\n     * call the postMessage with the msg and the image as payload.\n     *\n     * Thanks to what we have implemented in the _dispatch, this will\n     * return a promise with the processed image.\n     */\n\n  }, {\n    key: \"imageProcessing\",\n    value: function imageProcessing(payload) {\n      return this._dispatch({\n        msg: 'imageProcessing',\n        payload: payload\n      });\n    }\n  }, {\n    key: \"predict\",\n    value: function predict(payload) {\n      return this._dispatch({\n        msg: 'predict',\n        payload: payload\n      });\n    }\n  }]);\n\n  return CV;\n}(); // Export the same instant everywhere\n\n\nexport default new CV();","map":null,"metadata":{},"sourceType":"module"}